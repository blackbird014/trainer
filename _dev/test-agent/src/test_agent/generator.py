"""
Test generation functionality (optional, opt-in).

Supports:
- Basic unit test generation
- Missing test detection (coverage-based)
- Integration test generation (interface-based)
- Smart generation from docstrings/type hints
- Contract test generation
"""

from typing import List, Optional, Dict, Any, Set, Tuple
from pathlib import Path
import ast
import inspect
import importlib
import subprocess
import sys
import json
from dataclasses import dataclass


@dataclass
class Test:
    """Generated test definition."""
    name: str
    module: str
    target: str  # Function/class being tested
    test_code: str
    test_type: str  # "unit", "integration", etc.


class TestGenerator:
    """Generate tests from code, docstrings, and type hints."""

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize test generator.

        Args:
            project_root: Root directory of the project
        """
        if project_root is None:
            current = Path.cwd()
            while current != current.parent:
                if (current / "_dev").exists():
                    project_root = str(current)
                    break
                current = current.parent
            if project_root is None:
                project_root = str(Path.cwd())

        self.project_root = Path(project_root)
        self.dev_dir = self.project_root / "_dev"

    def generate_tests(
        self,
        module_path: str,
        strategy: str = "comprehensive",
        output_dir: Optional[str] = None
    ) -> List[Test]:
        """
        Generate tests for a module.

        Args:
            module_path: Path to module (relative to project root or absolute)
            strategy: Generation strategy ("comprehensive", "minimal", "focused")
            output_dir: Directory to write generated tests (default: tests/generated/)

        Returns:
            List of Test objects
        """
        # Resolve module path
        if Path(module_path).is_absolute():
            mod_path = Path(module_path)
        else:
            mod_path = self.project_root / module_path

        if not mod_path.exists():
            return []

        # Determine output directory
        if output_dir is None:
            tests_dir = mod_path / "tests" / "generated"
        else:
            tests_dir = Path(output_dir)

        tests_dir.mkdir(parents=True, exist_ok=True)

        # Find Python files in src/
        src_dir = mod_path / "src"
        if not src_dir.exists():
            return []

        generated_tests = []

        # Walk through source files
        for py_file in src_dir.rglob("*.py"):
            if py_file.name.startswith("__"):
                continue

            # Parse file
            try:
                with open(py_file, 'r') as f:
                    source = f.read()

                tree = ast.parse(source)
                module_name = self._extract_module_name(py_file)

                # Generate tests for classes and functions
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        test = self._generate_class_tests(node, module_name, py_file)
                        if test:
                            generated_tests.append(test)
                    elif isinstance(node, ast.FunctionDef):
                        if not node.name.startswith("_"):
                            test = self._generate_function_tests(node, module_name, py_file)
                            if test:
                                generated_tests.append(test)

            except Exception as e:
                # Skip files that can't be parsed
                continue

        # Write generated tests
        for test in generated_tests:
            test_file = tests_dir / f"test_auto_{test.name}.py"
            test_file.write_text(test.test_code)

        return generated_tests

    def _generate_class_tests(
        self,
        node: ast.ClassDef,
        module_name: str,
        source_file: Path
    ) -> Optional[Test]:
        """Generate tests for a class."""
        # Simple template-based generation
        test_code = f'''"""
Auto-generated tests for {node.name}
Generated by test-agent
"""

import pytest
from {module_name} import {node.name}


class Test{node.name}:
    """Tests for {node.name} class."""

    def test_init(self):
        """Test class initialization."""
        # TODO: Implement test
        pass

    def test_str(self):
        """Test string representation."""
        # TODO: Implement test
        pass
'''

        return Test(
            name=f"{node.name.lower()}",
            module=module_name,
            target=node.name,
            test_code=test_code,
            test_type="unit"
        )

    def _generate_function_tests(
        self,
        node: ast.FunctionDef,
        module_name: str,
        source_file: Path
    ) -> Optional[Test]:
        """Generate tests for a function."""
        # Simple template-based generation
        test_code = f'''"""
Auto-generated tests for {node.name}
Generated by test-agent
"""

import pytest
from {module_name} import {node.name}


def test_{node.name}():
    """Test {node.name} function."""
    # TODO: Implement test
    pass
'''

        return Test(
            name=node.name,
            module=module_name,
            target=node.name,
            test_code=test_code,
            test_type="unit"
        )

    def _extract_module_name(self, file_path: Path) -> str:
        """Extract module name from file path."""
        # Get relative path from src/
        parts = file_path.parts
        if "src" in parts:
            idx = parts.index("src")
            if idx + 1 < len(parts):
                module_parts = parts[idx + 1:-1]  # Exclude filename
                module_parts.append(file_path.stem)  # Add module name
                return ".".join(module_parts)
        return file_path.stem

    def _get_internal_modules(self) -> List[str]:
        """Get list of internal module names (normalized)."""
        try:
            from test_agent.discovery import ModuleDiscovery
            discovery = ModuleDiscovery(str(self.project_root))
            modules = discovery.discover_modules()
            # Normalize module names (replace - with _)
            return [m.replace("-", "_") for m in modules]
        except Exception:
            # Fallback: scan _dev directory
            if self.dev_dir.exists():
                return [d.name.replace("-", "_") for d in self.dev_dir.iterdir() if d.is_dir()]
            return []

    def find_missing_tests(
        self,
        module: str,
        coverage_threshold: float = 0.0
    ) -> Dict[str, List[str]]:
        """
        Find functions/classes that lack test coverage.

        Args:
            module: Module name
            coverage_threshold: Minimum coverage percentage to consider "tested"

        Returns:
            Dictionary mapping file paths to lists of untested items
        """
        from test_agent.coverage import CoverageAnalyzer

        # Get coverage report
        analyzer = CoverageAnalyzer(str(self.project_root))
        coverage = analyzer.check_coverage(module=module)

        # Get module path
        mod_path = self.dev_dir / module
        if not mod_path.exists():
            return {}

        # Find source files
        src_dir = mod_path / "src"
        if not src_dir.exists():
            return {}

        missing = {}
        tested_items = set()

        # Try to get detailed coverage from coverage.py output
        # This is a simplified version - in practice would parse coverage.xml
        for py_file in src_dir.rglob("*.py"):
            if py_file.name.startswith("__"):
                continue

            try:
                with open(py_file, 'r') as f:
                    source = f.read()

                tree = ast.parse(source)
                untested = []

                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        # Check if class is tested (simplified check)
                        class_name = node.name
                        if not self._has_test_for(class_name, mod_path):
                            untested.append(f"class {class_name}")

                    elif isinstance(node, ast.FunctionDef):
                        if not node.name.startswith("_"):
                            func_name = node.name
                            if not self._has_test_for(func_name, mod_path):
                                untested.append(f"function {func_name}")

                if untested:
                    rel_path = py_file.relative_to(mod_path)
                    missing[str(rel_path)] = untested

            except Exception:
                continue

        return missing

    def _has_test_for(self, item_name: str, module_path: Path) -> bool:
        """Check if there's a test file for an item."""
        tests_dir = module_path / "tests"
        if not tests_dir.exists():
            return False

        # Look for test files that might test this item
        for test_file in tests_dir.rglob("test_*.py"):
            try:
                content = test_file.read_text()
                # Simple check: does test file mention the item?
                if item_name.lower() in content.lower():
                    return True
            except Exception:
                continue

        return False

    def generate_missing_tests(
        self,
        module: str,
        output_dir: Optional[str] = None
    ) -> List[Test]:
        """
        Generate tests only for missing coverage.

        Args:
            module: Module name
            output_dir: Output directory

        Returns:
            List of generated Test objects
        """
        missing = self.find_missing_tests(module)

        mod_path = self.dev_dir / module
        if output_dir is None:
            tests_dir = mod_path / "tests" / "generated"
        else:
            tests_dir = Path(output_dir)

        tests_dir.mkdir(parents=True, exist_ok=True)

        generated_tests = []

        for file_path, items in missing.items():
            source_file = mod_path / file_path
            if not source_file.exists():
                continue

            try:
                with open(source_file, 'r') as f:
                    source = f.read()

                tree = ast.parse(source)
                module_name = self._extract_module_name(source_file)

                for item in items:
                    item_type, item_name = item.split(" ", 1)

                    if item_type == "class":
                        # Find class node
                        for node in ast.walk(tree):
                            if isinstance(node, ast.ClassDef) and node.name == item_name:
                                test = self._generate_class_tests(node, module_name, source_file)
                                if test:
                                    test.name = f"missing_{test.name}"
                                    generated_tests.append(test)
                                break

                    elif item_type == "function":
                        # Find function node
                        for node in ast.walk(tree):
                            if isinstance(node, ast.FunctionDef) and node.name == item_name:
                                test = self._generate_function_tests(node, module_name, source_file)
                                if test:
                                    test.name = f"missing_{test.name}"
                                    generated_tests.append(test)
                                break

            except Exception:
                continue

        # Write generated tests
        for test in generated_tests:
            test_file = tests_dir / f"test_auto_{test.name}.py"
            test_file.write_text(test.test_code)

        return generated_tests

    def analyze_dependencies(self, module: str) -> Dict[str, List[str]]:
        """
        Analyze module dependencies (what other modules it imports).

        Args:
            module: Module name

        Returns:
            Dictionary with dependency information
        """
        mod_path = self.dev_dir / module
        if not mod_path.exists():
            return {}

        src_dir = mod_path / "src"
        if not src_dir.exists():
            return {}

        dependencies = {
            "internal_modules": [],  # Other trainer modules
            "external_packages": [],  # External packages
            "imports": []  # All imports
        }

        for py_file in src_dir.rglob("*.py"):
            try:
                with open(py_file, 'r') as f:
                    source = f.read()

                tree = ast.parse(source)

                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            dep_name = alias.name.split('.')[0]
                            dependencies["imports"].append(dep_name)
                            # Check if it's an internal module
                            internal_modules = self._get_internal_modules()
                            if dep_name in internal_modules:
                                dependencies["internal_modules"].append(dep_name)
                            else:
                                dependencies["external_packages"].append(dep_name)

                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            dep_name = node.module.split('.')[0]
                            dependencies["imports"].append(dep_name)
                            # Check if it's an internal module
                            internal_modules = self._get_internal_modules()
                            if dep_name in internal_modules:
                                dependencies["internal_modules"].append(dep_name)
                            else:
                                dependencies["external_packages"].append(dep_name)

            except Exception:
                continue

        # Deduplicate
        dependencies["internal_modules"] = sorted(list(set(dependencies["internal_modules"])))
        dependencies["external_packages"] = sorted(list(set(dependencies["external_packages"])))
        dependencies["imports"] = sorted(list(set(dependencies["imports"])))

        return dependencies

    def generate_integration_tests(
        self,
        modules: List[str],
        output_dir: Optional[str] = None
    ) -> List[Test]:
        """
        Generate integration tests for module interactions.

        Args:
            modules: List of module names to test together
            output_dir: Output directory

        Returns:
            List of generated Test objects
        """
        if len(modules) < 2:
            return []

        # Analyze dependencies
        module_deps = {}
        for module in modules:
            deps = self.analyze_dependencies(module)
            module_deps[module] = deps

        # Find interactions (module A uses module B)
        interactions = []
        for module_a in modules:
            for module_b in modules:
                if module_a != module_b:
                    module_b_normalized = module_b.replace("-", "_")
                    if module_b_normalized in module_deps[module_a]["internal_modules"]:
                        interactions.append((module_a, module_b))

        # Generate integration tests
        generated_tests = []

        if output_dir is None:
            # Use first module's tests/integration directory
            mod_path = self.dev_dir / modules[0]
            tests_dir = mod_path / "tests" / "integration" / "generated"
        else:
            tests_dir = Path(output_dir)

        tests_dir.mkdir(parents=True, exist_ok=True)

        for module_a, module_b in interactions:
            test_code = f'''"""
Auto-generated integration test
Generated by test-agent

Tests integration between:
  - {module_a}
  - {module_b}
"""

import pytest


class Test{module_a.replace("-", "_").title()}{module_b.replace("-", "_").title()}Integration:
    """Integration tests for {module_a} with {module_b}."""

    def test_integration_basic(self):
        """Test basic integration between modules."""
        # TODO: Implement integration test
        # Example:
        # from {module_a.replace("-", "_")} import SomeClass
        # from {module_b.replace("-", "_")} import SomeProvider
        # 
        # provider = SomeProvider()
        # instance = SomeClass(provider)
        # result = instance.execute()
        # assert result is not None
        pass

    def test_integration_error_handling(self):
        """Test error handling in integration."""
        # TODO: Implement error handling test
        pass
'''

            test = Test(
                name=f"{module_a}_{module_b}_integration",
                module=f"{module_a}+{module_b}",
                target=f"{module_a}->{module_b}",
                test_code=test_code,
                test_type="integration"
            )
            generated_tests.append(test)

        # Write generated tests
        for test in generated_tests:
            test_file = tests_dir / f"test_auto_{test.name}.py"
            test_file.write_text(test.test_code)

        return generated_tests

    def generate_smart_tests(
        self,
        module_path: str,
        output_dir: Optional[str] = None
    ) -> List[Test]:
        """
        Generate tests using docstrings and type hints (smart generation).

        Args:
            module_path: Path to module
            output_dir: Output directory

        Returns:
            List of generated Test objects
        """
        if Path(module_path).is_absolute():
            mod_path = Path(module_path)
        else:
            mod_path = self.project_root / module_path

        if not mod_path.exists():
            return []

        if output_dir is None:
            tests_dir = mod_path / "tests" / "generated"
        else:
            tests_dir = Path(output_dir)

        tests_dir.mkdir(parents=True, exist_ok=True)

        generated_tests = []
        src_dir = mod_path / "src"

        if not src_dir.exists():
            return []

        for py_file in src_dir.rglob("*.py"):
            if py_file.name.startswith("__"):
                continue

            try:
                with open(py_file, 'r') as f:
                    source = f.read()

                tree = ast.parse(source)
                module_name = self._extract_module_name(py_file)

                for node in ast.walk(tree):
                    if isinstance(node, ast.FunctionDef):
                        if not node.name.startswith("_"):
                            test = self._generate_smart_function_test(node, module_name, py_file)
                            if test:
                                generated_tests.append(test)

                    elif isinstance(node, ast.ClassDef):
                        test = self._generate_smart_class_test(node, module_name, py_file)
                        if test:
                            generated_tests.append(test)

            except Exception:
                continue

        # Write generated tests
        for test in generated_tests:
            test_file = tests_dir / f"test_smart_{test.name}.py"
            test_file.write_text(test.test_code)

        return generated_tests

    def _generate_smart_function_test(
        self,
        node: ast.FunctionDef,
        module_name: str,
        source_file: Path
    ) -> Optional[Test]:
        """Generate smart test from function docstring and type hints."""
        # Extract docstring
        docstring = ast.get_docstring(node) or ""
        
        # Extract type hints
        args = []
        for arg in node.args.args:
            arg_info = {"name": arg.arg}
            if arg.annotation:
                # Try to unparse annotation (Python 3.9+)
                try:
                    if hasattr(ast, 'unparse'):
                        arg_info["type"] = ast.unparse(arg.annotation)
                    else:
                        arg_info["type"] = str(arg.annotation)
                except Exception:
                    arg_info["type"] = str(arg.annotation)
            args.append(arg_info)

        # Extract return type
        return_type = None
        if node.returns:
            try:
                if hasattr(ast, 'unparse'):
                    return_type = ast.unparse(node.returns)
                else:
                    return_type = str(node.returns)
            except Exception:
                return_type = str(node.returns)

        # Generate test code
        test_code = f'''"""
Auto-generated smart test for {node.name}
Generated by test-agent

Function signature: {node.name}({', '.join(a['name'] for a in args)})
Return type: {return_type or 'Any'}
"""

import pytest
from {module_name} import {node.name}
'''

        # Add docstring info if available
        if docstring:
            test_code += f'''
# Function docstring:
# {docstring[:200]}
'''

        test_code += f'''

def test_{node.name}():
    """Test {node.name} function."""
'''

        # Generate test cases based on docstring
        if "example" in docstring.lower() or "usage" in docstring.lower():
            test_code += '''    # TODO: Add test cases based on docstring examples
    # Example test:
    # result = function_name(arg1, arg2)
    # assert result is not None
'''
        else:
            test_code += f'''    # TODO: Implement test
    # Expected behavior: {docstring[:100] if docstring else 'Unknown'}
    pass
'''

        return Test(
            name=node.name,
            module=module_name,
            target=node.name,
            test_code=test_code,
            test_type="unit"
        )

    def _generate_smart_class_test(
        self,
        node: ast.ClassDef,
        module_name: str,
        source_file: Path
    ) -> Optional[Test]:
        """Generate smart test from class docstring."""
        docstring = ast.get_docstring(node) or ""

        # Find __init__ method
        init_method = None
        for item in node.body:
            if isinstance(item, ast.FunctionDef) and item.name == "__init__":
                init_method = item
                break

        # Extract init args
        init_args = []
        if init_method:
            for arg in init_method.args.args:
                if arg.arg != "self":
                    init_args.append(arg.arg)

        test_code = f'''"""
Auto-generated smart test for {node.name}
Generated by test-agent

Class docstring:
{docstring[:200] if docstring else 'No docstring'}
"""

import pytest
from {module_name} import {node.name}


class Test{node.name}:
    """Tests for {node.name} class."""

    def test_init(self):
        """Test class initialization."""
'''

        if init_args:
            test_code += f'''        # Initialize with: {', '.join(init_args)}
        # instance = {node.name}({', '.join(f'{arg}=...' for arg in init_args)})
        # assert instance is not None
        pass
'''
        else:
            test_code += '''        instance = {node.name}()
        assert instance is not None
'''

        test_code += '''
    def test_str(self):
        """Test string representation."""
        # TODO: Implement test
        pass
'''

        return Test(
            name=f"{node.name.lower()}",
            module=module_name,
            target=node.name,
            test_code=test_code,
            test_type="unit"
        )

    def generate_contract_tests(
        self,
        consumer_module: str,
        provider_module: str,
        output_dir: Optional[str] = None
    ) -> List[Test]:
        """
        Generate contract tests between modules.

        Args:
            consumer_module: Module that uses the provider
            provider_module: Module that provides the interface
            output_dir: Output directory

        Returns:
            List of generated Test objects
        """
        consumer_path = self.dev_dir / consumer_module
        provider_path = self.dev_dir / provider_module

        if not consumer_path.exists() or not provider_path.exists():
            return []

        if output_dir is None:
            tests_dir = consumer_path / "tests" / "integration" / "generated"
        else:
            tests_dir = Path(output_dir)

        tests_dir.mkdir(parents=True, exist_ok=True)

        # Analyze interfaces
        consumer_deps = self.analyze_dependencies(consumer_module)
        provider_normalized = provider_module.replace("-", "_")

        if provider_normalized not in consumer_deps["internal_modules"]:
            return []  # No dependency, no contract to test

        # Generate contract test
        test_code = f'''"""
Auto-generated contract test
Generated by test-agent

Tests contract between:
  Consumer: {consumer_module}
  Provider: {provider_module}

Verifies that {consumer_module} correctly uses {provider_module} interface.
"""

import pytest


class Test{consumer_module.replace("-", "_").title()}{provider_module.replace("-", "_").title()}Contract:
    """Contract tests verifying {consumer_module} -> {provider_module} interface."""

    def test_provider_interface_compliance(self):
        """Test that provider implements expected interface."""
        # TODO: Verify provider has required methods/properties
        # Example:
        # from {provider_module.replace("-", "_")} import ProviderClass
        # assert hasattr(ProviderClass, 'required_method')
        pass

    def test_consumer_usage(self):
        """Test that consumer correctly uses provider."""
        # TODO: Test consumer with provider
        # Example:
        # from {consumer_module.replace("-", "_")} import ConsumerClass
        # from {provider_module.replace("-", "_")} import ProviderClass
        # 
        # provider = ProviderClass()
        # consumer = ConsumerClass(provider)
        # result = consumer.execute()
        # assert result is not None
        pass

    def test_error_handling(self):
        """Test error handling in contract."""
        # TODO: Test error scenarios
        pass
'''

        test = Test(
            name=f"{consumer_module}_{provider_module}_contract",
            module=f"{consumer_module}+{provider_module}",
            target=f"{consumer_module}->{provider_module}",
            test_code=test_code,
            test_type="contract"
        )

        # Write test
        test_file = tests_dir / f"test_auto_{test.name}.py"
        test_file.write_text(test.test_code)

        return [test]

